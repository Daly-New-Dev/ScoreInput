// --- CONFIGURATION ---
const SPREADSHEET_ID = '1dJOb56GjrlGXtOwhydrsko2qM9fSCBfjQ-OE1rxTbp0'; 
const SHEET_NAME = 'Scores'; // Master student list

// --- SERVE HTML ---
function doGet(e) {
  const action = e.parameter.action;
  
  if (!action) {
    return HtmlService.createHtmlOutputFromFile('index')
      .setTitle('Student Grading System')
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
      .addMetaTag('viewport', 'width=device-width, initial-scale=1');
  }

  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);

  // --- 1. Get Dropdown Data ---
  if (action == 'getDropdownData') {
    const sheet = ss.getSheetByName(SHEET_NAME);
    if(!sheet) return ContentService.createTextOutput(JSON.stringify({error: "Sheet not found"}));

    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    // Subjects start at Column H (Index 7)
    const subjects = headers.slice(7); 
    
    const classes = [...new Set(data.slice(1).map(r => r[3]).filter(String))].sort(); // Col D
    const grades = [...new Set(data.slice(1).map(r => r[4]).filter(String))].sort((a,b)=>a-b); // Col E
    
    // Get Rooms with Grade Mapping
    const rawRooms = data.slice(1).map(r => ({grade: r[4], room: r[5]})); 
    const uniqueRooms = [];
    const seenRooms = new Set();
    
    rawRooms.forEach(item => {
      const g = String(item.grade).trim();
      const r = String(item.room).trim();
      if(g && r) {
        const key = g + "_" + r;
        if(!seenRooms.has(key)) {
          seenRooms.add(key);
          uniqueRooms.push({grade: g, room: r});
        }
      }
    });
    uniqueRooms.sort((a,b) => a.room.localeCompare(b.room, undefined, {numeric: true}));

    // Period List
    const periodSheet = ss.getSheetByName('Periods');
    let periods = [];
    if (periodSheet) {
      const pData = periodSheet.getDataRange().getValues();
      periods = pData.slice(1)
        .filter(r => r[0] && r[1]) 
        .map(r => ({ name: r[0], value: r[1], order: r[2] }))
        .sort((a, b) => a.order - b.order) 
        .map(p => ({name: p.name, value: p.value})); 
    }

    return ContentService.createTextOutput(JSON.stringify({
      subjects: subjects,
      classes: classes,
      grades: grades,
      rooms: uniqueRooms,
      periods: periods
    })).setMimeType(ContentService.MimeType.JSON);
  }

  // --- 2. Get Students (UPDATED) ---
  if (action == 'getStudents') {
    const sheet = ss.getSheetByName(SHEET_NAME);
    const mode = e.parameter.mode;
    const grade = e.parameter.grade;
    const value = e.parameter.value;
    
    const data = sheet.getDataRange().getValues();
    let students = [];
    
    data.slice(1).forEach((row, index) => {
      const rowGrade = String(row[4]); // Col E
      const rowClass = String(row[3]); // Col D
      const rowRoom  = String(row[5]); // Col F
      
      let match = false;
      if (mode == 'class') {
        if (rowClass === value) match = true;
      } else if (mode == 'room') {
         if (rowGrade == grade && rowRoom == value) match = true;
      }

      if (match) {
        students.push({
          id: row[0],          // Col A
          name: row[1],        // Col B
          gender: row[2],      // Col C
          class: row[3],       // Col D
          grade: row[4],       // Col E - Added Grade
          room: row[5],        // Col F
          tableNumber: row[6], // Col G - Table Number
          rowIndex: index + 2 
        });
      }
    });

    students.sort((a, b) => a.name.localeCompare(b.name, 'km'));

    return ContentService.createTextOutput(JSON.stringify(students))
      .setMimeType(ContentService.MimeType.JSON);
  }
  
  // --- 3. EXPORT EXCEL ---
  if (action == 'exportExcel') {
    const mode = e.parameter.mode;   
    const grade = e.parameter.grade; 
    const value = (mode === 'class') ? e.parameter.class : e.parameter.room; 
    const period = e.parameter.period;

    if (!period) return HtmlService.createHtmlOutput("<h3>Error: Period not selected.</h3>");

    const sourceSheet = ss.getSheetByName(period);
    if (!sourceSheet) return HtmlService.createHtmlOutput(`<h3>Error: Sheet for "${period}" not found.</h3>`);

    const data = sourceSheet.getDataRange().getValues();
    const header = data[0];
    
    let filteredRows = [];
    
    // Using Loop for complex filtering
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const rowGrade = String(row[4]); 
      const rowClass = String(row[3]); 
      const rowRoom = String(row[5]);  
      
      let match = false;
      if (mode === 'class') {
        if (rowClass === value) match = true;
      } else {
        if (rowGrade === grade && rowRoom === value) match = true;
      }
      
      if (match) {
        filteredRows.push(row);
      }
    }

    if (filteredRows.length === 0) {
      return HtmlService.createHtmlOutput("<h3>No data found for this selection.</h3>");
    }

    // Sort for Export
    filteredRows.sort((a, b) => String(a[1]).localeCompare(String(b[1]), 'km'));

    const fileName = `Export_${period}_${mode}_${value}`;
    const tempSS = SpreadsheetApp.create(fileName);
    const tempSheet = tempSS.getSheets()[0];

    const outputData = [header, ...filteredRows];
    tempSheet.getRange(1, 1, outputData.length, outputData[0].length).setValues(outputData);
    tempSheet.getRange(1, 1, 1, outputData[0].length).setFontWeight("bold").setBackground("#DDDDDD");
    tempSheet.autoResizeColumns(1, outputData[0].length);

    SpreadsheetApp.flush(); 
    const fileId = tempSS.getId();
    DriveApp.getFileById(fileId).setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
    const downloadUrl = `https://docs.google.com/spreadsheets/d/${fileId}/export?format=xlsx`;

    return HtmlService.createHtmlOutput(`
      <html>
        <body style="font-family: sans-serif; text-align: center; padding-top: 50px;">
          <h2>Generating Excel...</h2>
          <p>Download should start automatically.</p>
          <script>window.location.href = "${downloadUrl}";</script>
        </body>
      </html>
    `);
  }
}

// --- POST HANDLER (UPDATED LOGIC) ---
function doPost(e) {
  try {
    const data = JSON.parse(e.postData.contents);
    if (data.action == 'submitScores') {
      const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
      let periodSheet = ss.getSheetByName(data.payload.period);
      
      if (!periodSheet) {
        return ContentService.createTextOutput(JSON.stringify({status: 'error', message: 'Period Sheet not found'}));
      }

      // 1. Find Subject Column
      const headers = periodSheet.getRange(1, 1, 1, periodSheet.getLastColumn()).getValues()[0];
      const colIndex = headers.indexOf(data.payload.subject);
      
      if (colIndex === -1) {
        return ContentService.createTextOutput(JSON.stringify({status: 'error', message: 'Subject not found'}));
      }

      // 2. Build Lookup Map (Key: Grade_Room_TableNumber -> RowIndex)
      // This ensures we find the correct student even if rows are sorted differently.
      const sheetData = periodSheet.getDataRange().getValues();
      const rowMap = new Map();
      
      for (let i = 1; i < sheetData.length; i++) { // Skip header
        const row = sheetData[i];
        // Col E (Idx 4) = Grade, Col F (Idx 5) = Room, Col G (Idx 6) = Table Number
        const key = String(row[4]).trim() + "_" + String(row[5]).trim() + "_" + String(row[6]).trim();
        rowMap.set(key, i + 1); // Store 1-based Row Index
      }

      // 3. Write Scores using Lookup
      let savedCount = 0;
      data.payload.scores.forEach(item => {
        const key = String(item.grade).trim() + "_" + String(item.room).trim() + "_" + String(item.tableNumber).trim();
        const targetRowIndex = rowMap.get(key);
        
        if (targetRowIndex) {
          // Write score to the found row
          periodSheet.getRange(targetRowIndex, colIndex + 1).setValue(item.score);
          savedCount++;
        }
      });

      return ContentService.createTextOutput(JSON.stringify({
        status: 'success', 
        message: `Saved ${savedCount} scores successfully`
      }));
    }
  } catch (error) {
    return ContentService.createTextOutput(JSON.stringify({status: 'error', message: error.toString()}));
  }
}